// ---------------------------------------------------------------------
// Definition of standard relations
// ---------------------------------------------------------------------

// Extended coherence order
let eco = (rf | mo | fr)+

// Same location
let loc = loc-overlap ^=

// ---------------------------------------------------------------------
// RC11 Happens-before
// ---------------------------------------------------------------------

let ppo = po
view porf = (po | rf | tc | tj | lin)+

// Optimized calculation of synchronizes-with
// Save the view of write messages

let relseq = [REL] ; ([F|TC] ; po)? ; (rf ; rmw)*
let sw_to_r = relseq ; rf ; [ACQ]
let sw_to_f = relseq ; rf ; po ; [F|TJ] ; [ACQ]
let sw = sw_to_r | sw_to_f
let asw = tc | tj | lin

assert sw = [REL] ; ([F|TC] ; po)? ; (rf ; rmw)* ; rf ; (po ; [F|TJ])? ; [ACQ]

// Happens-before
view hb = (po | sw_to_r | asw | sw_to_f)+

assert hb = (po | sw | asw)+

// Also save an 'abstract' hb that discards plock synchronization (relinche)
view hbRelinche = (po | tc | tj | lin
	| (relseq ; rf ; (po ; [F|TJ|TB])? ; [NPLK & ACQ]))+ (genmc: "if (!getConf()->collectLinSpec && !getConf()->checkLinSpec) lab->addView({}); else")

// ---------------------------------------------------------------------
// A more elaborate definition of happens-before which should normally
// have constant-time view calculations
// 
// view hb = (hbg ; rf ; [ACQ])?
//        | hba ; [F & ACQ]
//        | hb ; po
// 
// and hbg = hb ; [F & REL] ; po; [W & RLX]
//         | hb ; [W & REL]
//         | hbg ; rf ; rmw
// 
// and hba = hbg ; rf | hba ; po
// ---------------------------------------------------------------------

// ---------------------------------------------------------------------
// Yet another definition with fewer views, where only the calculation
// for [F & ACQ] is non-constant (it is linear)
// 
// view hb = (hbg ; rf ; [ACQ])?
//        | hb ; [R & RLX] ; po ; [F & ACQ]
//        | hb ; po
// 
// and hbg = hb ; [F & REL] ; po; [W & RLX]
//         | hb ; [W & REL]
//         | hbg ; rf ; rmw
// ---------------------------------------------------------------------



// ---------------------------------------------------------------------
// RC11 Consistency axioms
// ---------------------------------------------------------------------

// No load buffering
// acyclic (po | rf)

// Coherence : Optimize the checking of irreflexive (hb ; eco)
export coherence hb

// RMW atomicity
// check  mo-imm ; [UW] <= rf ; po-imm

// (poi; poi | ) poi;[NEXCL | R] --> custom predicate


// Sequential consistency order
let FSC = [F] ; [SC]
let fhb = [F] ; hb
let hbf = hb ; [F]
let scb = po | rf | mo | fr
let psc = [SC] ; po ; hb ; po ; [SC] // sed /po/po-imm/ ?
        | [SC] ; fhb? ; scb ; hbf? ; [SC]
        | FSC ; hb ; FSC
        | FSC ; hb ; eco ; hb ; FSC
        | SC ; po ; SC
export acyclic psc unless [SC];any = 0

// ---------------------------------------------------------------------
// RC11 error detection
// ---------------------------------------------------------------------

let ww_conflict = [W] ; loc-overlap ; [W]
let wr_conflict = [W] ; loc-overlap ; [R] | [R] ; loc-overlap ; [W]
let conflicting = ww_conflict | wr_conflict
let na_conflict = [NA] ; conflicting | conflicting ; [NA]

// GenMC needs to handle the no-alloc case (access validity)

export error VE_AccessNonMalloc unless  alloc <= hb
export error VE_DoubleFree      unless  [FREE|HPRET] ; loc-overlap ; [FREE|HPRET] = 0

export error VE_AccessFreed     unless  alloc^-1? ; free ; [FREE] <= hb
export error VE_AccessFreed     unless  [FREE] ; free^-1 ; alloc = 0
export error VE_AccessFreed     unless  [NOTHPPROT] ; alloc^-1? ; free ; [HPRET] <= hb
export error VE_AccessFreed     unless  [HPRET] ; free^-1 ; alloc ; [NOTHPPROT] = 0

export error VE_RaceNotAtomic   unless  na_conflict <= hb
export warning VE_WWRace        unless  ww_conflict <= porf // hb
